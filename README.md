# DesignPattern
《大话设计模式》Golang实现

两个原则
1. Program to an interface, not an implementation. (面向接口编程，而不是具体的实现)
2. Favor object composition over class inheritance.（如果某个场景的代码复用既可以通过类继承实现， 也可以通过对象组合实现， 尽量选择对象组合的设计方式）

组合与继承的讨论(IS-A, HAS-A)
两者区别：继承往往是一种白盒复用，子类直接面对父类的实现细节。是紧耦合的、编译期间就确定好的静态的行为，组合是动态的、运行期间决定的。继承是一种多态工具，只有在1：每个子类都是父类；2:父类不会暴露脆弱的api的情况下可取。

1. 简单工厂模式
根据参数的不同返回不同类的实例。方法是专门定义一个类来创建其他类的实例，被创建的类一般有共同父类。
优势：将对象创建与对象本身业务处理分离以降低耦合度，修改参数不太需要修改源代码。
劣势：拓展困难，加新产品就需要修改工厂逻辑。要点在于，只需要传入一个参数就可以获取所徐亚的对象，而无需知道其创建细节。


2. 策略模式
如果存在多个类，它们的区别仅在于行为不同，那么使用策略模式可以让一个对象在许多行为中选择一个行为。也就是类的行为或者算法可以在运行时动态调整。
优势：策略模式宗旨不在于减少if-else，而在于遵循程序的开闭原则，即：对扩展是开放的，对修改是关闭的。简单来说，就是把不同的业务交给独立的单元处理，优化了单元检测，因为每个算法都有自己的类，可以用自己的接口单独测试（DPE）。

3. 单一职责
单一职责原则（SRP）：就一个类而言，应该仅有一个引起它变化的原因。

4. 开放-封闭
开放-封闭原则（OCP）：对拓展是开放的，对修改是封闭的。

5. 依赖倒转
里氏代换原则（LSP）：子类型应该能替换它们的父类型。
基于此，高层不应该依赖低层模块，两者都应该依赖抽象。
抽象不应该依赖细节，细节应该依赖抽象。
依赖倒转可以说是面向对象的标志，如果编写时考虑的是如何设计抽象编程而不是针对细节编程，即所以依赖关系都是终止于抽象类或接口，那就是面向对象的设计。

6. 装饰模式
动态得给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
当系统需要新功能时，可以向旧的类中添加新的代码或者使用继承，而前者会增加主类的复杂度，后者本身是一种静态方法（组合优于继承），用户不能控制增加行为的方法和时机。
装饰模式提供了一个好的解决方案：将每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此客户代码可以在运行时根据需要有选择得使用装饰功能包装对象。换句话说，装饰模式允许向一个现有的对象添加新功能，而不改变其结构。它是现有的类的一个包装。
优势：有效地把类的核心职责和装饰功能区分开了，比继承更灵活。
劣势：装饰模式的装饰顺序很重要，理想情况是装饰类之间彼此独立。除此之外还会产生很多小对象和装饰类，增加系统的复杂性，debug无能。
https://www.runoob.com/design-pattern/decorator-pattern.html

7. 代理模式
为其他对象提供一种代理以控制对这个对象的访问。
使用场合：远程代理、虚拟代理（HTML）、安全代理、智能指引（智能指针）。

8. 工厂方法模式
定义一个用于创建对象的接口，让子类决定实例话哪一个类。工厂方法使得一个类的实例化延迟到其子类。
目的：使得适用对象和创建对象是分离的，并且客户端总是引用抽象产品。
优点：克服了简单工厂违背开放-封闭的缺点，又保持了封装对象创建的优点。

9. 原型模式
从一个对象创建另外一个可定制对象，而且不需知道任何创建的细节。

10. 模板方法模式
定义操作中算法的骨架，而把一些步骤延迟到子类中。此时不改变算法结构就可以改变算法某些特定步骤。
与建造者模式单从功能、执行流上基本相似，区别在于，一个继承了base class的一套算法骨架，而另一个通过组合的方式，通过指挥类决定骨架。

11. 迪米特法则
如果两个类不必直接通信，就不应该发生直接相互作用。如果一个类需要调用另一个类的方法，可以通过第三者转发。

12. 外观模式
为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得子系统易用。

13. 建造者模式
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

14. 观察者模式
定义一种一对多的依赖关系，让多个观察者对象同时监听某一抽象对象。这个抽象对象在状态发生变化时会通知所有观察者，又叫“发布-订阅模式”。
适用于一个对象的改变需要同时同时改变其他对象的时候。

15. 抽象工厂模式
定义：提供一个创建一系列相关或者互相依赖对象的接口而无需制定它们具体的类

16. 状态模式
定义：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
适用场景：主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，即“长方法(Long Method)”。方法是把状态的判断逻辑转移到不同状态的一系列类当中。

17. 适配器模式
定义：将一个类的接口转换成客户希望的另外一个接口。
Adapter使得原本由于接口不兼容而不能一起工作的类可以一起工作。
适用场景：两个类功能相似但是接口不同，而且双方都不太容易修改时。

18. 备忘录模式
定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
适用场景：功能比较复杂，但需要维护和记录属性历史的类，也可用于撤销。

19. 组合模式
定义：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。
适用场景：需求中是体现部分与整体层次的结构时，以及希望用户忽略组合对象与单个对象的不同，统一使用组合结构中的所有对象时。

20. 迭代器模式
定义：提供一种方法顺序访问一个聚合对象中各个元素，而不暴露该对象的内部表示。

21. 单例模式
定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

22. 桥接模式
定义：将抽象部分（interface）与它的实现部分（struct、func）分离，使它们都可以独立地变化。
例子：咖啡的容量、口味和温度。

23. 命令模式
定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

24. 职责链模式
定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的饮用，而不需保持它所有的后继者。
与状态模式区别在于，一，职责链的链是在客户端连接的，要更灵活一点；二，职责链的本质是第同一个问题的反应，状态模式牵扯对多种状态的不同响应。

25. 中介者模式
定义：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。

26. 享元模式
定义：运用共享技术有效的支持大量细粒度的对象。
应用场景：需要生成大量细粒度的类来表示数据时，而且这些类功能上相同，只是表示有差异。

27. 解释器模式
定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

28. 访问者模式
定义：表示一个作用于某对象结构中的各元素饿操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
把数据结构和作用与数据结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。缺点在于增加新的数据结构会比较困难。

模式总结
# 创建型模式
  1. 抽象工厂模式
  2. 建造者模式
  3. 工厂方法模式
  4. 原型模式
  5. 单例模式

# 结构型
  1. 适配器模式
  2. 桥接模式
  3. 组合模式
  4. 装饰模式
  5. 外观模式
  6. 享元模式
  7. 代理模式

# 行为型：控制流->对象间关系
  1. 观察者模式
  2. 模版方法
  3. 命令
  4. 状态
  5. 职责链
  6. 解释器
  7. 中介者
  8. 访问者
  9. 策略模式
  10. 备忘录
  11. 迭代器
